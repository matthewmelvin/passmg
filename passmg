#!/usr/bin/perl -T
# $Id: passmg,v 1.21 2005/02/14 03:54:39 root Exp $

# Password Manager - (C) WebCentral Pty Ltd 

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# PERL DOC #################################################################

=head1 NAME

B<passmg> - A utility for managing and accessing stored passwords.

=head1 SYNOPSIS

B<passmg> [-h|-v|-C]

B<passmg> [-l] [regex]

B<passmg> [-c|-a|-d] [key@host]

B<passmg> [-g|-r] [user]

=head1 DESCRIPTION

B<passmg> is a suid perl script designed to lessen the problems
of shared/common passwords amongst administators.  Although having
passwords being used by multiple individuals is itself a risk,
especially when auditing actions taken with that password, it is
often an inescapable nessessity.  This problem is further aggrevated by
a tendency to change shared passwords very infrequently due largly to
the difficulties involved in diseminating the new passwords to all
parties in a way that does not itself further compromise it.

B<passmg> addresses this problem by keeping a central repository
of passwords stored in PGP encrypted files.  Each user who has
been granted access to the repository has their own PGP secret
and private key pair.  Each password file is encrypted using all
the available public keys meaning each user can access the respository
using their own pass phrase.  Thus the PGP key pair provides both
authentication and access controls.

When granting or revoking access for a user the master key (root)
is used to decrypt and reencrypt all the password files.  This master
key is not acutally special in anyway except being associated with the
root user.  As the root user can control other user's access B<passmg>
will only allow root to make use of the program if logged in to a the
host's physical console.  To prevent users by-passing B<passmg> and
accessing the various files directly the repository is made accessable
only to root and the B<passmg> script made suid and sgid.  Use of mandatory
ALC (such as the LIDS patch for Linux) on this directory is also advisable.

=head1 OPTIONS

=head2 B<-h>

Will print a brief description of usage and paremeters.

=head2 B<-v>

Will print the version identifier for the program.

=head2 B<-l regex>

Will list the available encrypted password files matching the provided regex.

=head2 B<-C>

Allows a user to change the passphrase on their own secret PGP key.

=head2 B<-a key@host>

Allows a user to add a new password file to the repository.

=head2 B<-c key@host>

Allows a user to change to contents of an encrypted password file.

=head2 B<-d key@host>

Allows a user to delete an existing password file from the repository.

=head2 B<-g user>

Allows root to grant access to the repository to a new user.

=head2 B<-g user>

Allows root to revoke an existing users access to the repository.

=head1 BUGS

There is no locking beyond what is done by gpg itself so there is the potential
of race conditions of more than one user is manipluating key files.  This might
give unpredictable results to users but should not result in corruption of the
repository.

To date this script has only been tested and used on Linux.  It is entirely
possible it may not work at all on other platforms.

=head1 SEE ALSO

gpg(1)

=head1 VERSION

$Id: passmg,v 1.21 2005/02/14 03:54:39 root Exp $

=head1 AUTHOR

Matthew Melvin <matthewm@webcentral.com.au>

=cut

# GLOBALS ##################################################################

%ENV = ();
$ENV{'PATH'} = "/usr/local/bin:/usr/bin:/bin";
$ENV{'GNUPGHOME'} = "/usr/local/passmg";

use strict;
use Symbol;
use File::Basename;
use Getopt::Std;
use POSIX;
use POSIX qw(:termios_h);
use Sys::Syslog;
use Sys::Syslog qw(:DEFAULT setlogsock);

use vars qw/ @_ARGV $ARGV0 $VER $DEBUG $HIST $OWNER /;

sub main ();
sub show_help ();
sub get_passwd ($$);
sub check_key ($);
sub check_auth ($$);
sub create_key ($);
sub delete_key ($);
sub change_key ($);
sub import_keys ();
sub list_ascs ();
sub encrypt_asc ($$@);
sub decrypt_asc ($$$);
sub delete_asc ($);
sub putlog ($$);

$ARGV0 = ($0 =~ /^\/|^[a-zA-Z]:/) ? $0 : getcwd() . "/$0";
$ARGV0 =~ s%\\%/%g;
1 while ($ARGV0 =~ s%/\./%/%);
1 while ($ARGV0 =~ s%/[^/]+/\.\./%/%);
1 while ($ARGV0 =~ s%^/\.\./%/%);
foreach ($ARGV0, @ARGV) {
        s%/+%/%g;
        /(.+)/;
        push(@_ARGV, $1)
}
$ARGV0 = basename($_ARGV[0]);

$VER = do {
	my @r = (q$Revision: 1.21 $ =~ /\d+/g);
	sprintf "%d."."%02d", @r
};

$DEBUG = 0;

$HIST = 3;

$OWNER = 0;

main();

die "Unreachable code reached";

# MAIN BODY ################################################################

sub main () {
	my(%opts, $args);
	my($user, $pass, $buf);
	my(@pub, @asc);

	$args = join(" ", $ARGV0, @ARGV);
	$args =~ /(.+)/;
	$args = $1;

	unless (getopts('hvicCadl:g:r:H:', \%opts)) {
		show_help();
		exit(1);
	}

	if (defined($opts{H}) && (scalar keys %opts > 2) || (!defined($opts{H}) && scalar keys %opts > 1)) {
		print STDERR "Error: only one function may be specified at once.\n";
		show_help();
		exit(1);
	}

	if ($opts{h}) {
		show_help();
		exit(0);
	}

	if ($opts{v}) {
		print STDOUT "$ARGV0 version $VER\n";
		exit(0);
	}

	if (defined($opts{H})) {
		unless (($opts{H} > 0) && ($opts{H} =~ /^(\d+)$/)) {
			print STDERR "Error: invalid history option specified.\n";
			show_help();
			exit(1);
		}
		$HIST = $1;
		unless ($opts{c}) {
			print STDERR "Error: history only valid when changing keys.\n";
			show_help();
			exit(1);
		}
	}

	if (($opts{i} || $opts{l} || $opts{g} || $opts{r}) && ($#ARGV >= 0)) {
		print STDERR "Error: too many command argument(s) specified.\n";
		show_help();
		exit(1);
	} elsif (($opts{i} || $opts{l} || $opts{g} || $opts{r} || $opts{C}) && ($#ARGV < 0)) {
		1; # that's fine - do nothing
	} elsif ($opts{C} && $#ARGV >= 0) {
		print STDERR "Error: too many command argument(s) specified.\n";
		show_help();
		exit(1);
	} elsif ($#ARGV > 0) {
		print STDERR "Error: too many command argument(s) specified.\n";
		show_help();
		exit(1);
	} elsif ($#ARGV < 0) {
		print STDERR "Error: you must specify a key\@host argument.\n";
		show_help();
		exit(1);
	} elsif ($ARGV[0] =~ /^([\w@\-\.]+)$/) {
		$ARGV[0] = $1;
	} else {
		$ARGV[0] =~ s/[\w@\-\.]+//g;
		print STDERR "Error: bogus characters in argument: '$ARGV[0]'\n";
		exit(1);
	}
	
	unless ($buf = ttyname(fileno(0))) {
		putlog('warning', "Called from non-tty device: $1");
		print STDERR "Fatal: stdin is not a tty device: $!\n";
		exit(1);
	}
	if ($> == $<) {
		$OWNER=1;
		if ($buf !~ /^\/dev\/tty[0-9A-Z]+$/) {
			putlog('warning', "Called by owner from non-console: $buf");
			# print STDERR "Fatal: run by owner from non-console: $buf\n";
			# exit(1);
		}
	}

	putlog('notice', "Started: " . scalar getpwuid($>) ."($>)/" . scalar getpwuid($<) . "($<) on $buf");
	putlog('notice', $args);

	unless (umask(077)) {
		putlog('err',  "Fatal: unable to set umask to 077: $!");
		print STDERR "Fatal: unable to set umask to 077: $!\n";
		exit(1);
	}

	if ($opts{i}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to initilise repository by non-owner");
			print STDERR "Need to be owner\n";
			exit(1);
		}
		unless (( -d $ENV{'GNUPGHOME'}) || mkdir($ENV{'GNUPGHOME'}, 777)) {
			putlog('err',  "Fatal: unable to mkdir for $ENV{'GNUPGHOME'}: $!");
			print STDERR "Fatal: unable to mkdir for $ENV{'GNUPGHOME'}: $!\n";
			exit(1);
		}
		unless (chdir($ENV{'GNUPGHOME'})) {
			putlog('err',  "Fatal: unable to chdir to $ENV{'GNUPGHOME'}: $!");
			print STDERR "Fatal: unable to chdir to $ENV{'GNUPGHOME'}: $!\n";
			exit(1);
		}
		if (@pub = import_keys()) {
			putlog('notice', "Incomplete: Directory already initilised");
			print STDERR "Directory already initilised\n";
			exit(1);
		}
		print STDOUT "\nCreating key for owner ...\n";
		unless (($user = getpwuid($<)) && create_key($user)) {
			putlog('notice', "Incomplete: Key creation failed");
			print STDERR "Key creation failed\n";
			exit(1);
		}
		putlog('notice', "Completed.");
		print "\nDone\n";
		exit(0);
	}
	
	unless (chdir($ENV{'GNUPGHOME'})) {
		putlog('err',  "Fatal: unable to chdir to $ENV{'GNUPGHOME'}: $!");
		print STDERR "Fatal: unable to chdir to $ENV{'GNUPGHOME'}: $!\n";
		exit(1);
	}

	$pass = get_passwd("Enter your password", 0);

	unless (($user = getpwuid($<))
		 && (($<, $() = ($>, $)))
		 && (check_key($user))
		 && (check_auth($user, $pass))) {
		putlog('notice', "Incomplete: Authorization refused.");
		print STDERR "Authorization refused.\n";
		exit(1);
	}

	if ($opts{C}) {
		print STDOUT "\nExecuting interactive GPG to change key for $user...\n";
		# change_key exec's gpg  so does not return
		change_key($user);
		putlog('notice', "Incomplete: key change gpg should not have returned");
		print STDERR "Key change failed\n";
		exit(1);
	}
		
	if ($opts{g}) {
		print STDOUT "\nCreating key for $opts{g} ...\n";
		unless ($OWNER) {
			putlog('warning', "Attempt to grant access to $opts{g} by non-owner");
			print STDERR "Need to be owner\n";
			exit(1);
		}
		if (check_key($opts{g})) {
			putlog('notice', "Incomplete: Key already exists");
			print STDERR "Key already exists\n";
			exit(1);
		}
		unless (create_key($opts{g})) {
			putlog('notice', "Incomplete: Key creation failed");
			print STDERR "Key creation failed\n";
			exit(1);
		}
	}

	if ($opts{r}) {
		print STDOUT "\nRevoking key for $opts{r} ...\n";
		unless ($OWNER) {
			putlog('warning', "Attempt to revoke access from $opts{r} by non-owner");
			print STDERR "Need to be owner\n";
			exit(1);
		}
		if ($user eq $opts{r}) {
			putlog('notice', "Incomplete: Can't delete own key");
			print STDERR "Can't delete own key\n";
			exit(1);
		}
		unless (check_key($opts{r})) {
			putlog('notice', "Incomplete: Key doesn't exists");
			print STDERR "Key doesn't exists\n";
			exit(1);
		}
		unless (delete_key($opts{r})) {
			putlog('notice', "Incomplete: Key deletion failed");
			print STDERR "Key deletion failed\n";
			exit(1);
		}
	}

	if ($opts{g} || $opts{r}) {
		print STDOUT "\nRe-encrypting asc files ...\n";
		unless (@pub = import_keys()) {
			putlog('notice', "Incomplete: Key import failed");
			print STDERR "Key import failed\n";
			exit(1);
		}
		unless (@asc = list_ascs()) {
			putlog('notice', "Incomplete: Key list failed");
			print STDERR "Key list failed\n";
			exit(1);
		}
		foreach (@asc) {
			unless ($buf = decrypt_asc($user, $pass, $_)) {
				putlog('notice', "Incomplete: Asc decryption failed: $_");
				print STDERR "Asc decryption failed: $_\n";
				next;
			}
			unless (encrypt_asc($buf, $_, @pub)) {
				putlog('notice', "Incomplete: Asc encryption failed: $_");
				print STDERR "Asc encryption failed: $_\n";
			}
		}

		putlog('notice', "Completed.");
		print STDOUT "\nDone.\n";
		exit(0);
	}

	if ($opts{l}) {
		print STDOUT "\nAvailable keys ...\n";
		unless (@asc = list_ascs()) {
			putlog('notice', "Incomplete: Key list failed");
			print STDERR "Key list failed\n";
			exit(1);
		}
		foreach (@asc) {
			s/\.asc$//;
			next unless (/$opts{l}/);
			print "$_\n";
		}
		putlog('notice', "Completed.");
		print STDOUT "\nDone.\n";
		exit(0);
	}

	if ($opts{a}) {
		unless ($ARGV[0] =~ /^\S+@\S+$/) {
			putlog('notice', "Incomplete: Key must be in the form key\@host");
			print STDERR "Key must be in the form key\@host\n";
			exit(1);
		}
		print STDOUT "\nAdding new key in $ARGV[0] ...\n";
		if (check_asc($ARGV[0])) {
			putlog('notice', "Incomplete: Key already exists");
			print STDERR "Key already exists\n";
			exit(1);
		}
		$buf = "";
	}
	if ($opts{c}) {
		print STDOUT "\nChanging key in file $ARGV[0] ...\n";
		unless (check_asc($ARGV[0])) {
			putlog('notice', "Incomplete: Asc doesn't exists");
			print STDERR "Asc doesn't exists\n";
			exit(1);
		}
		unless ($buf = decrypt_asc($user, $pass, $ARGV[0])) {
			putlog('notice', "Incomplete: Authoriztion refused");
			print STDERR "Authoriztion refused\n";
			exit(1);
		}
	}
	if ($opts{a} || $opts{c}) {
		$buf .= get_passwd("Enter new password", 1);
		if ($buf =~ /(([^\n]+\n){1,$HIST})$/) {
			$buf = $1;
		};
		print STDOUT "\nEncrypting asc file $ARGV[0] ...\n";
		unless (@pub = import_keys()) {
			putlog('notice', "Incomplete: Key import failed");
			print STDERR "Key import failed\n";
			exit(1);
		}
		unless (encrypt_asc($buf, $ARGV[0], @pub)) {
			putlog('notice', "Incomplete: Asc encryption failed");
			print STDERR "Asc encryption failed\n";
			exit(1);
		}
		putlog('notice', "Completed.");
		print STDOUT "\nDone.\n";
		exit(0);
	}

	if ($opts{d}) {
		print STDOUT "\nDeleting asc file $ARGV[0] ...\n";
		unless (check_asc($ARGV[0])) {
			putlog('notice', "Incomplete: Asc doesn't exists");
			print STDERR "Asc doesn't exists\n";
			exit(1);
		}
		unless (delete_asc($ARGV[0])) {
			putlog('notice', "Incomplete: Asc deleltion failed");
			print STDERR "Asc deleltion failed\n";
			exit(1);
		}
		putlog('notice', "Completed.");
		print STDOUT "\nDone.\n";
		exit(0);
	}

	print STDOUT "\nDecrypting asc file $ARGV[0] ...\n";
	unless ($buf = decrypt_asc($user, $pass, $ARGV[0])) {
		putlog('notice', "Incomplete: Asc decryption failed");
		print STDERR "Asc decryption failed\n";
		exit(1);
	}
	print "\n$buf\n";
		
	putlog('notice', "Completed.");
	print STDOUT "Done.\n";
	exit(0);
}

# SUB FUNCS ################################################################

sub show_help () {
	print STDOUT "$ARGV0 version $VER

	usage: $ARGV0 [<opts>] [<key\@host>]
		-v  show version: will display the RCS rev.
		-h  show help: causes this message to be shown.
		-c  change key: changes the stored password for a key.
		-C  change pass: changes the access password for user.
		-a  add key: adds a new key entry to the password list.
		-d  delete key: deletes a key from the password list.

		-l <regex>: list all the keys matching the regex

		-g <user>: Grants a user access to managed passwords. 
		-r <user>: Revokes a user's acesss to passwords.

		-H <number>:  used with -c to specify the number of past
                       passwords to retain.  Must be 1 or greater.
		\n";
	return();
}

sub get_passwd ($$) {
	my($prompt) = $_[0];
	my($confirm) = $_[1];
	my($term, $flags);
	my($buf, $key);

	$term = POSIX::Termios->new();

	$term->getattr(0);
	$flags = $term->getlflag();

	$term->setlflag($flags &~ (ECHO | ECHOK | ICANON));
	$term->setattr(0, TCSANOW);

	$key = 0;
	while ($buf ne $key) {
		print STDERR "Passwords do not match!\n" if ($key);
		print STDOUT "$prompt: ";
		$key = <STDIN>;
		print STDOUT "\n";
		if ($confirm) {
			print STDOUT "Re-enter to confirm: ";
			$buf = <STDIN>;
			print STDOUT "\n";
		} else {
			last;
		}
	}

	$term->setlflag($flags);
	$term->setattr(0, TCSANOW);

	return($key);
}

sub check_key ($) {
	my($usr) = $_[0];
	my($p) = gensym;
	my($buf, $out);

	unless (( -f "$usr.sec") && ( -f "$usr.pub")) {
		putlog('err', "Error: no key rings for verification of $usr.");
		return(0);
	}

	$buf = open($p, "-|");

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for key verification: $!");
		print STDERR "Error: unable to fork gpg for key verification: $!\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $!\n";
			exit(1);
		}	
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $!\n";
			exit(1);
		}	
		exec {'gpg'} ('gpg', '-q', '--no-secmem-warning',
			'--list-secret-keys', '--no-default-keyring',
			'--keyring', "$usr.pub", '--secret-keyring', "$usr.sec");
		putlog('err',  "Error: unable to exec gpg for key verification: $!");
		print STDERR "Error: unable to exec gpg for key verification: $!\n";
		exit(1);
	}
	
	while (<$p>) {
		chomp();
		next unless (/^sec\s.+( |\(|<)($usr)( \)|@)/);
		$out = $2;
	}

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: key verifing gpg process was killed: $buf");
		print STDERR "Error: key verifing gpg process was killed: $buf\n";
		return(0);
	}

	unless ($out) {
		putlog('err', "Error key verification failed.");
		return(0);
	}

	return(1);
}

sub check_auth ($$) {
	my($usr) = $_[0];
	my($key) = $_[1];
	my($buf);
	my($p) = gensym;

	unless (( -f "$usr.sec") && ( -f "$usr.pub")) {
		putlog('err', "Error: no key rings for authentication of $usr.");
		return(0);
	}

	$buf = open($p, "|-");

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for authenticaton: $!");
		print STDERR "Error: unable to fork gpg for authenticaton: $!\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDERR) && open(STDERR, "</dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $!\n";
			exit(1);
		}	
		exec {'gpg'} ('gpg', '-q', '-a', '-o', '/dev/null',
			'--no-secmem-warning',
			'--no-tty', '--passphrase-fd', '0',
			'--no-default-keyring',
			'--keyring', "$usr.pub",
			'--secret-keyring', "$usr.sec",
			'-u', "$usr", '-s', "$usr.sec");
		putlog('err',  "Error: unable to exec gpg for authenticaton: $!\n");
		print STDERR "Error: unable to exec gpg for authenticaton: $!\n";
		exit(1);
	}

	print $p "$key\n";

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: authenticating gpg process was killed: $buf");
		print STDERR "Error: authenticating gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;

	if ($buf != 0) {
		putlog('err', "Error: gpg authentication failed.");
		return(0);
	}

	return(1);
}

sub create_key ($) {
	my($usr) = $_[0];
	my($buf, $key, @pwe);
	my($p) = gensym;

	unless (@pwe = getpwnam($usr)) {
		putlog('err',  "Error: Can't find details for user $usr: $!");
		print STDERR "Error: Can't find details for user $usr: $!\n";
		return(0);
	}

	$pwe[6] = "$usr\@localhost" unless ($pwe[6]);

	$key = get_passwd("Enter new password", 1);

	$buf = open($p, "|-");

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for key creation: $!");
		print STDERR "Error: unable to fork gpg for key creation: $!\n";
		return(0);
	} elsif ($buf == 0) {
		exec {'gpg'} ('gpg', '--no-greeting', '--no-secmem-warning', 
			'--no-default-keyring',
			'--secret-keyring', '/dev/null', '--keyring', '/dev/null',
			'--batch', '--gen-key', '--yes');
		putlog('err',  "Error: unable to exec gpg for key creation: $!");
		print STDERR "Error: unable to exec gpg for key creation: $!\n";
		exit(1);
	}

	print $p "
		%echo $pwe[6] ($usr) <$usr\@localhost>
		Key-Type: DSA
		Key-Length: 1024
		Subkey-Type: ELG-E
		Subkey-Length: 1024
		Name-Real: $pwe[6]
		Name-Comment: $usr
		Name-Email: $usr\@localhost
		Expire-Date: 0
		Passphrase: $key
		%pubring $usr.pub
		%secring $usr.sec
		%commit
		%echo done\n";

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: key creation gpg process was killed: $buf");
		print STDERR "Error: key creation gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: key creation gpg process returned non-zero: $buf");
		print STDERR "Error: key creation gpg process returned non-zero: $buf\n";
		return(0);
	}

	return(1);
}

sub delete_key ($) {
	my($usr) = $_[0];

	$usr =~ /^([\w\.\-]+)$/;
	$usr = $1;

	unless (unlink("$usr.sec")) {
		putlog('warning',  "Warning: unable to delete key: $usr.sec: $!");
		print STDERR "Warning: unable to delete key: $usr.sec: $!\n";
		return(0);
	}

	unless (unlink("$usr.pub")) {
		putlog('warning',  "Warning: unable to delete key: $usr.pub: $!");
		print STDERR "Warning: unable to delete key: $usr.pub: $!\n";
		return(0);
	}

	return(1);
}

sub change_key ($) {
	my($usr) = $_[0];

	exec {'gpg'} ('gpg', '-q', 
			'--no-secmem-warning',
			'--no-default-keyring',
			'--keyring', "$usr.pub",
			'--secret-keyring', "$usr.sec",
			'--edit-key', $usr, 'passwd', 'save', 'quit');

	putlog('err',  "Error: unable to exec gpg for key change: $!");
	print STDERR "Error: unable to exec gpg for key change: $!\n";
	return(1);
}

sub import_keys () {
	my($d) = gensym();
	my($buf, @buf, @pub);

	unless (( ! -e 'pubring.gpg')  || unlink('pubring.gpg')) {
		putlog('err',  "Error: unable to unlink existing pubring.gpg: $!");
		print STDERR "Error: unable to unlink existing pubring.gpg: $!\n";
		return(());
	}
	unless (( ! -e 'secring.gpg')  || unlink('secring.gpg')) {
		putlog('err',  "Error: unable to unlink existing secring.gpg: $!");
		print STDERR "Error: unable to unlink existing secring.gpg: $!\n";
		return(());
	}
	
	unless (opendir($d, ".")) {
		putlog('err',  "Error: unable to open dir for reading: $!");
		print STDERR "Error: unable to open dir for reading: $!\n";
		return(());
	}

	@buf =  readdir($d);

	foreach (@buf) {
		next unless (/^([^\.]+\.pub)$/);
		push @pub, $1;
	}

	close($d);	

	unless ($#pub >= 0) {
		putlog('err',  "Error: no keys to import: *.pub");
		print STDERR "Error: no keys to import: *.pub\n";
		return(());
	}

	$buf = fork();

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for import: $!");
		print STDERR "Error: unable to fork gpg for import: $!\n";
		return(());
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $!\n";
			exit(1);
		}	
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $!\n";
			exit(1);
		}	
		exec {'gpg'} ('gpg', '--fast-import', '--no-secmem-warning', @pub);
		putlog('err',  "Error: unable to exec gpg for import: $!");
		print STDERR "Error: unable to exec gpg for import: $!\n";
		exit(1);
	}

	$buf = waitpid($buf, 0);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: importing gpg process was killed: $buf");
		print STDERR "Error: importing gpg process was killed: $buf\n";
		return(());
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: importing process returned non-zero: $buf");
		print STDERR "Error: importing gpg process returned non-zero: $buf\n";
		return(());
	}

	return(@pub);
}

sub list_ascs () {
	my($d) = gensym();
	my(@asc, @buf);

	unless (opendir($d, ".")) {
		putlog('err',  "Error: unable to open dir for reading: $!");
		print STDERR "Error: unable to open dir for reading: $!\n";
		return(());
	}

	@buf =  readdir($d);

	foreach (@buf) {
		next unless (/^(.+@.+\.asc)$/);
		push @asc, $1;
	}

	unless ($#asc >= 0) {
		putlog('err',  "Error: no keys to list: *@*.asc");
		print STDERR "Error: no keys to list: *@*.asc\n";
		return(());
	}

	close($d);

	return(@asc);
}

sub check_asc ($) {
	my($file) = $_[0];
	my($p) = gensym;
	my($buf, $out);

	$file .= ".asc" unless ($file =~ /\.asc$/);


	unless ( -f $file) {
		return(undef);
	}

	$buf = open($p, "-|");

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for asc verification: $!");
		print STDERR "Error: unable to fork gpg for asc verification: $!\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $!\n";
			exit(1);
		}	
		unless (close(STDERR) && open(STDERR, ">&STDOUT")) {
			putlog('err',  "Error: unable to map gpg's stderr to stdout: $!");
			print STDERR "Error: unable to map gpg's stderr to stdout: $!\n";
			exit(1);
		}	
		exec {'gpg'} ('gpg', '--no-secmem-warning',
			'--list-only', '--no-default-keyring',
			'--keyring', '/dev/null', '--secret-keyring', '/dev/null',
			$file);
		putlog('err',  "Error: unable to exec gpg for asc verification: $!");
		print STDERR "Error: unable to exec gpg for asc verification: $!\n";
		exit(1);
	}
	
	while (<$p>) {
		chomp();
		next unless (/^gpg: encrypted with/);
		$out .= $_;
	}

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: asc verifing gpg process was killed: $buf");
		print STDERR "Error: asc verifing gpg process was killed: $buf\n";
		return(0);
	}


	return(0) unless ($out);

	return(1);
}


sub encrypt_asc ($$@) {
	my($key) = $_[0];
	my($file) = $_[1];
	my($buf, $out);
	my($p) = gensym;
	my(@pub); shift; shift;
	foreach (@_) { s/\.pub$//; push @pub, "-r", $_; }

	$file .= ".asc" unless ($file =~ /\.asc$/);

	unless (( ! -e $file)  || unlink($file)) {
		putlog('err',  "Error: unable to unlink existing $file: $!");
		print STDERR "Error: unable to unlink existing $file: $!\n";
		return(0);
	}

	$buf = open($p, "|-");

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for encryption: $!");
		print STDERR "Error: unable to fork gpg for encryption: $!\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $!\n";
			exit(1);
		}	
		exec {'gpg'} ('gpg', '-a', '--encrypt', '--always-trust', 
			'--no-secmem-warning',
			@pub, '-o', $file);
		putlog('err',  "Error: unable to exec gpg for encryption: $!");
		print STDERR "Error: unable to exec gpg for encryption: $!\n";
		exit(1);
	}

	print $p "$key\n";
	
	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: encrypting gpg process was killed: $buf");
		print STDERR "Error: encrypting gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: encrypting gpg process returned non-zero: $buf");
		print STDERR "Error: encrypting gpg process returned non-zero: $buf\n";
		return(0);
	}

	return(1);
}

sub decrypt_asc ($$$) {
	my($usr) = $_[0];
	my($key) = $_[1];
	my($file) = $_[2];
	my($buf, $out);
	my($p) = gensym;
	my($r) = gensym;
	my($w) = gensym;
	local($/) = undef;

	$file .= ".asc" unless ($file =~ /\.asc$/);

	unless ( -f $file) {
		putlog('err',  "Error: no key file for $file");
		print STDERR "Error: no key file for $file\n";
		return(undef);
	}

	unless (pipe($r, $w)) {
		putlog('err',  "Error: unable to create password channel: $!");
		print STDERR "Error: unable to create password channel: $!\n";
		return(undef);
	}
	unless (fcntl($r, F_GETFD, $buf)) {
		putlog('err',  "Error: unable to F_GETFD on password channel: $!");
		print STDERR "Error: unable to F_GETFD on password channel: $!\n";
	}
	$buf &= FD_CLOEXEC;
	unless (fcntl($r, F_SETFD, $buf)) {
		putlog('err',  "Error: unable to F_SETFD on password channel: $!");
		print STDERR "Error: unable to F_SETFD on password channel: $!\n";
	}

	$buf = open($p, "-|");

	unless (defined($buf)) {
		putlog('err',  "Error: unable to fork gpg for decryption: $!");
		print STDERR "Error: unable to fork gpg for decryption: $!\n";
		return(undef);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $!\n";
			exit(1);
		}	
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $!");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $!\n";
			exit(1);
		}	
		exec {'gpg'} ('gpg', '--decrypt', 
			'--no-tty', '--passphrase-fd', fileno($r),
			'--no-secmem-warning', '--no-default-keyring',
			'--secret-keyring', "$usr.sec",
			'--keyring', "$usr.pub", '-u', "$usr",
			"$file");
		putlog('err',  "Error: unable to exec gpg for decryption: $!");
		print STDERR "Error: unable to exec gpg for decryption: $!\n";
		exit(1);
	}

	print $w "$key\n";
	close($w);

	$out = <$p>;
	$out =~ s/\n+$/\n/s;

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: decrypting gpg process was killed: $buf");
		print STDERR "Error: decrypting gpg process was killed: $buf\n";
		return(undef);
	}

	$buf = $? >> 8;
	return(undef) if ($buf != 0);

	return($out);
}

sub delete_asc ($) {
	my($file) = $_[0];

	$file .= ".asc" unless ($file =~ /\.asc$/);

	unless ( -f $file) {
		putlog('err',  "Error: no asc key for $file");
		print STDERR "Error: no asc key for $file\n";
		return(undef);
	}

	unless (unlink($file)) {
		putlog('err',  "Warning: unable to asc key: $file: $!");
		print STDERR "Warning: unable to asc key: $file: $!\n";
	}

	return(1);
}

sub putlog ($$) {
	my($pri) = $_[0];
	my($msg) = $_[1];

	chomp($msg);
	$msg =~ s/([\000-\011\013-\037])/sprintf("\\%03o", unpack("C", $1))/eg;

	openlog($ARGV0, 'ndelay,pid', 'authpriv');
	setlogsock('unix');
	syslog($pri, "%s", $msg);
	closelog();
}
